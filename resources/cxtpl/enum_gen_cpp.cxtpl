<CX=> // parameters begin

using namespace cxtpl_utils;

const auto GeneratedEnumName
  = GetWithDefault<std::string>(cxtpl_params, "GeneratedEnumName", "");

const auto generator_path
  = GetWithDefault<std::string>(cxtpl_params, "generator_path", "");

std::vector<std::string> generator_includes
  = GetWithDefault<std::vector<std::string>>
      (cxtpl_params, "generator_includes", std::vector<std::string>{});

// parameters end
/* no newline */ <=CX><CX=l>
// This is generated file. Do not modify directly.
// Path to the code generator: <CX=r> generator_path <=CX>.

<CX=l> for(const auto& fileName: generator_includes) {
<CX=r> fileName <=CX>
<CX=l> } // end for

#include <iostream>
#include <cstring>
#include <type_traits>

namespace cxxctp {
namespace generated {

<CX=r> GeneratedEnumName <=CX>::_enumerated operator & (
  const <CX=r> GeneratedEnumName <=CX>::_enumerated& lhs, const <CX=r> GeneratedEnumName <=CX>::_enumerated& rhs )
{
  return static_cast<<CX=r> GeneratedEnumName <=CX>::_enumerated>(
    static_cast<<CX=r> GeneratedEnumName <=CX>::_enumerated_t>(lhs)
      & static_cast<<CX=r> GeneratedEnumName <=CX>::_enumerated_t>(rhs));
}

<CX=r> GeneratedEnumName <=CX>::_enumerated operator ^ (
  const <CX=r> GeneratedEnumName <=CX>::_enumerated& lhs, const <CX=r> GeneratedEnumName <=CX>::_enumerated& rhs )
{
  return static_cast<<CX=r> GeneratedEnumName <=CX>::_enumerated>(
    static_cast<<CX=r> GeneratedEnumName <=CX>::_enumerated_t>(lhs)
      ^ static_cast<<CX=r> GeneratedEnumName <=CX>::_enumerated_t>(rhs));
}

<CX=r> GeneratedEnumName <=CX>::_enumerated operator ~ (
  const <CX=r> GeneratedEnumName <=CX>::_enumerated& rhs )
{
  return static_cast<<CX=r> GeneratedEnumName <=CX>::_enumerated>(
    ~static_cast<<CX=r> GeneratedEnumName <=CX>::_enumerated_t>(rhs));
}

<CX=r> GeneratedEnumName <=CX>::_enumerated operator | (
  <CX=r> GeneratedEnumName <=CX>::_enumerated& lhs, const <CX=r> GeneratedEnumName <=CX>::_enumerated& rhs )
{
  return static_cast<<CX=r> GeneratedEnumName <=CX>::_enumerated>(
    static_cast<<CX=r> GeneratedEnumName <=CX>::_enumerated_t>(lhs)
      | static_cast<<CX=r> GeneratedEnumName <=CX>::_enumerated_t>(rhs));
}

<CX=r> GeneratedEnumName <=CX>::_enumerated operator &= (
  <CX=r> GeneratedEnumName <=CX>::_enumerated& lhs, const <CX=r> GeneratedEnumName <=CX>::_enumerated& rhs )
{
  lhs
    = lhs & rhs;
  return lhs;
}

<CX=r> GeneratedEnumName <=CX>::_enumerated operator ^= (
  <CX=r> GeneratedEnumName <=CX>::_enumerated& lhs, const <CX=r> GeneratedEnumName <=CX>::_enumerated& rhs )
{
  lhs
    = lhs ^ rhs;
  return lhs;
}

<CX=r> GeneratedEnumName <=CX>::_enumerated operator |= (
  <CX=r> GeneratedEnumName <=CX>::_enumerated& lhs, const <CX=r> GeneratedEnumName <=CX>::_enumerated& rhs )
{
  lhs
    = lhs | rhs;
  return lhs;
}

/*bool operator ==(const <CX=r> GeneratedEnumName <=CX>::_enumerated &a, const <CX=r> GeneratedEnumName <=CX>::_enumerated &b)
{
  return static_cast<<CX=r> GeneratedEnumName <=CX>::_enumerated_t>(a)
          == static_cast<<CX=r> GeneratedEnumName <=CX>::_enumerated_t>(b);
}

bool operator !=(const <CX=r> GeneratedEnumName <=CX>::_enumerated &a, const <CX=r> GeneratedEnumName <=CX>::_enumerated &b)
{
  return static_cast<<CX=r> GeneratedEnumName <=CX>::_enumerated_t>(a)
          != static_cast<<CX=r> GeneratedEnumName <=CX>::_enumerated_t>(b);
}

bool operator <(const <CX=r> GeneratedEnumName <=CX>::_enumerated &a, const <CX=r> GeneratedEnumName <=CX>::_enumerated &b)
{
  return static_cast<<CX=r> GeneratedEnumName <=CX>::_enumerated_t>(a)
          < static_cast<<CX=r> GeneratedEnumName <=CX>::_enumerated_t>(b);
}

bool operator <=(const <CX=r> GeneratedEnumName <=CX>::_enumerated &a, const <CX=r> GeneratedEnumName <=CX>::_enumerated &b)
{
  return static_cast<<CX=r> GeneratedEnumName <=CX>::_enumerated_t>(a)
          <= static_cast<<CX=r> GeneratedEnumName <=CX>::_enumerated_t>(b);
}

bool operator >(const <CX=r> GeneratedEnumName <=CX>::_enumerated &a, const <CX=r> GeneratedEnumName <=CX>::_enumerated &b)
{
  return static_cast<<CX=r> GeneratedEnumName <=CX>::_enumerated_t>(a)
          > static_cast<<CX=r> GeneratedEnumName <=CX>::_enumerated_t>(b);
}

bool operator >=(const <CX=r> GeneratedEnumName <=CX>::_enumerated &a, const <CX=r> GeneratedEnumName <=CX>::_enumerated &b)
{
  return static_cast<<CX=r> GeneratedEnumName <=CX>::_enumerated_t>(a)
          >= static_cast<<CX=r> GeneratedEnumName <=CX>::_enumerated_t>(b);
}*/

// Stream extraction operator: read from stream
std::istream& operator >> ( std::istream& ins, <CX=r> GeneratedEnumName <=CX>& val ) /*noexcept*/
{
  std::string str;
  ins >> str;
  val = <CX=r> GeneratedEnumName <=CX>::FromString( str.c_str() );
  if (val == <CX=r> GeneratedEnumName <=CX>::TOTAL)
    ins.setstate( ins.rdstate() | std::ios::failbit );
  return ins;
}

// Stream insertion operator: write to stream
std::ostream& operator << ( std::ostream& outs, const <CX=r> GeneratedEnumName <=CX>& val ) /*noexcept*/
{
  const auto str = val.ToString();
  if(str) {
    return outs << str;
  }
  return outs;
}

<CX=r> GeneratedEnumName <=CX>::const_value_iterator <CX=r> GeneratedEnumName <=CX>::values_begin() const { return values_.begin(); }

<CX=r> GeneratedEnumName <=CX>::const_value_iterator <CX=r> GeneratedEnumName <=CX>::values_end() const { return values_.end(); }

<CX=r> GeneratedEnumName <=CX>::const_name_iterator <CX=r> GeneratedEnumName <=CX>::names_begin() const { return names_.begin(); }

<CX=r> GeneratedEnumName <=CX>::const_name_iterator <CX=r> GeneratedEnumName <=CX>::names_end() const { return names_.end(); }

bool <CX=r> GeneratedEnumName <=CX>::test_flag(<CX=r> GeneratedEnumName <=CX>::_enumerated flag) const noexcept {
  return static_cast<bool>(
        static_cast<<CX=r> GeneratedEnumName <=CX>::_enumerated_t>(value_)
        & static_cast<<CX=r> GeneratedEnumName <=CX>::_enumerated_t>(flag));
}

<CX=r> GeneratedEnumName <=CX>::<CX=r> GeneratedEnumName <=CX>(const <CX=r> GeneratedEnumName <=CX>::_enumerated value)
  : value_(value) { }

const <CX=r> GeneratedEnumName <=CX> &<CX=r> GeneratedEnumName <=CX>::operator =(const char *dummy) noexcept {
  value_ = <CX=r> GeneratedEnumName <=CX>::FromString(dummy);
  return *this;
}

<CX=r> GeneratedEnumName <=CX> operator & (
  const <CX=r> GeneratedEnumName <=CX>& lhs, const <CX=r> GeneratedEnumName <=CX>& rhs )
{
  return lhs.value_
    & rhs.value_;
}

<CX=r> GeneratedEnumName <=CX> operator ^ (
  const <CX=r> GeneratedEnumName <=CX>& lhs, const <CX=r> GeneratedEnumName <=CX>& rhs )
{
  return lhs.value_
    ^ rhs.value_;
}

<CX=r> GeneratedEnumName <=CX> operator ~ ( const <CX=r> GeneratedEnumName <=CX>& rhs )
{
  return ~rhs.value_;
}

<CX=r> GeneratedEnumName <=CX> operator | (
  <CX=r> GeneratedEnumName <=CX>& lhs, const <CX=r> GeneratedEnumName <=CX>& rhs )
{
  return lhs.value_
    | rhs.value_;
}

<CX=r> GeneratedEnumName <=CX> operator &= (
  <CX=r> GeneratedEnumName <=CX>& lhs, const <CX=r> GeneratedEnumName <=CX>& rhs )
{
  lhs.value_
    &= rhs.value_;
  return lhs;
}

<CX=r> GeneratedEnumName <=CX> operator ^= (
  <CX=r> GeneratedEnumName <=CX>& lhs, const <CX=r> GeneratedEnumName <=CX>& rhs )
{
 lhs.value_
    ^= rhs.value_;
  return lhs;
}

<CX=r> GeneratedEnumName <=CX> operator |= (
  <CX=r> GeneratedEnumName <=CX>& lhs, const <CX=r> GeneratedEnumName <=CX>& rhs )
{
  lhs.value_
    |= rhs.value_;
  return lhs;
}

/*bool operator ==(const <CX=r> GeneratedEnumName <=CX> &a, const <CX=r> GeneratedEnumName <=CX> &b)
{
  return a.value_ == b.value_;
}

bool operator !=(const <CX=r> GeneratedEnumName <=CX> &a, const <CX=r> GeneratedEnumName <=CX> &b)
{
  return a.value_ != b.value_;
}*/

bool operator <(const <CX=r> GeneratedEnumName <=CX> &a, const <CX=r> GeneratedEnumName <=CX> &b)
{
  return a.value_ < b.value_;
}

bool operator <=(const <CX=r> GeneratedEnumName <=CX> &a, const <CX=r> GeneratedEnumName <=CX> &b)
{
  return a.value_ <= b.value_;
}

bool operator >(const <CX=r> GeneratedEnumName <=CX> &a, const <CX=r> GeneratedEnumName <=CX> &b)
{
  return a.value_ > b.value_;
}

bool operator >=(const <CX=r> GeneratedEnumName <=CX> &a, const <CX=r> GeneratedEnumName <=CX> &b)
{
  return a.value_ >= b.value_;
}

<CX=r> GeneratedEnumName <=CX>::_enumerated <CX=r> GeneratedEnumName <=CX>::FromString(const char *txt) noexcept {
  for (size_t index = 0; index < _count; ++index) {
    if (names_[index] == txt)
      return static_cast<_enumerated>(values_[index]);
  }
  return _enumerated::TOTAL; // TODO: use optional
}

<CX=r> GeneratedEnumName <=CX>::_enumerated_t <CX=r> GeneratedEnumName <=CX>::ToNumber(const <CX=r> GeneratedEnumName <=CX>::_enumerated val) noexcept {
  return
      static_cast<_enumerated_t>(val);
}

const char *<CX=r> GeneratedEnumName <=CX>::ToString(const <CX=r> GeneratedEnumName <=CX>::_enumerated val) noexcept {
  for (size_t index = 0; index < _count; ++index) {
    if (values_[index] == static_cast<_enumerated_t>(val))
      return names_[index];
  }
  return nullptr;
}

<CX=r> GeneratedEnumName <=CX>::_enumerated <CX=r> GeneratedEnumName <=CX>::FromNumber(const <CX=r> GeneratedEnumName <=CX>::_enumerated_t val) noexcept {
  auto val_to_type = static_cast<std::underlying_type_t<_enumerated>>(val);
  for (size_t index = 0; index < _count; ++index) {
    if (values_[index] == val_to_type)
      return static_cast<_enumerated>(values_[index]);
  }
  return _enumerated::TOTAL; // TODO: use optional
}

const char *<CX=r> GeneratedEnumName <=CX>::ToString() const noexcept {
  return ToString(value_);
}

<CX=r> GeneratedEnumName <=CX>::_enumerated_t <CX=r> GeneratedEnumName <=CX>::ToNumber() const noexcept {
  return ToNumber(value_);
}

const <CX=r> GeneratedEnumName <=CX> &<CX=r> GeneratedEnumName <=CX>::operator =(<CX=r> GeneratedEnumName <=CX>::_enumerated_t dummy) noexcept {
  value_ = FromNumber(dummy);
  return *this;
}

const <CX=r> GeneratedEnumName <=CX> &<CX=r> GeneratedEnumName <=CX>::operator =(<CX=r> GeneratedEnumName <=CX> dummy) noexcept {
  value_ = dummy.value_;
  return *this;
}

<CX=r> GeneratedEnumName <=CX>::operator _enumerated() const { return value_; }

} // namespace cxxctp
} // namespace generated

// Support using as key in dictionaries and maps
size_t std::hash<cxxctp::generated::<CX=r> GeneratedEnumName <=CX>>::operator()(
  const cxxctp::generated::<CX=r> GeneratedEnumName <=CX>& x) const
{
  return std::hash<size_t>()(
    static_cast<size_t>(x.ToNumber()));
}
