<CX=> // parameters begin

std::string headerGuard
  = GetWithDefault<std::string>(dictionary, "headerGuard", "");

std::string GeneratedEnumName
  = GetWithDefault<std::string>(dictionary, "GeneratedEnumName", "");

std::string GeneratedEnumType
  = GetWithDefault<std::string>(dictionary, "GeneratedEnumType", "");

std::map<std::string, std::string> GeneratedEnumItems
  = GetWithDefault<std::map<std::string, std::string>>(dictionary, "GeneratedEnumItems", std::map<std::string, std::string>{});

const size_t GeneratedEnumItemsSize = GeneratedEnumItems.size();
if(!GeneratedEnumItemsSize) {
  // TODO: report error
}

std::vector<std::string> generator_includes
  = GetWithDefault<std::vector<std::string>>
      (dictionary, "generator_includes", std::vector<std::string>{});

// parameters end
<=CX>
// This is generated file. Do not modify directly.
// Path to the code generator: {{generator_path}}.

<CX=l> if(!headerGuard.empty()) {
#ifndef {{headerGuard}}
#define {{headerGuard}}
<CX=l> } else {
#pragma once
<CX=l> } // !headerGuard.empty()
<CX=l> printf("headerGuard4 \n");

<CX=l> for(const auto& fileName: generator_includes) {
<CX=r> fileName <=CX>
<CX=l> } // end for

#include <array>
#include <functional>

namespace cxxctp {
namespace generated {

struct <CX=r> GeneratedEnumName <=CX>
{
  typedef <CX=r> GeneratedEnumType <=CX> _enumerated_t;
  typedef _enumerated_t _value_t; // alias
  typedef const char* const _name_t;

  enum class _enumerated : _enumerated_t {
<CX=l>  { // startscope
<CX=l>    size_t elemIter = 0;
<CX=l>    for(const auto& [value, name]: GeneratedEnumItems) {
<CX=l>      const std::string delim  =
<CX=l>        (elemIter != GeneratedEnumItemsSize) ? "," : "";
<CX=l>      const std::string comment  =
<CX=l>        name + " = " + value + " at " + std::to_string(elemIter);
    <CX=r>name<=CX> = <CX=r>value<=CX> <CX=r>delim<=CX> // <CX=r>comment<=CX>
<CX=l>      elemIter++;
<CX=l>    } // endfor
<CX=l>  } // endscope
  };

  // allows to hide some enum values
  static constexpr auto NONE     = _enumerated::NONE;
  static constexpr auto Box     = _enumerated::Box;
  static constexpr auto Sphere  = _enumerated::Sphere;
  static constexpr auto TOTAL  = _enumerated::TOTAL;

  _enumerated value_;

  static constexpr size_t _count = <CX=s> GeneratedEnumItemsSize <=CX>;

  using value_container =
    std::array<_enumerated_t, _count>;
  using value_iterator =
    typename value_container::iterator;
  using const_value_iterator =
    typename value_container::const_iterator;

  const_value_iterator values_begin() const;
  const_value_iterator values_end() const;

  using name_container =
    std::array<_name_t, _count>;
  using name_iterator =
    typename name_container::iterator;
  using const_name_iterator =
    typename name_container::const_iterator;

  const_name_iterator names_begin() const;
  const_name_iterator names_end() const;

  friend std::ostream& operator << ( std::ostream& outs, const <CX=r> GeneratedEnumName <=CX>& val ); /*noexcept*/
  friend std::istream& operator >> ( std::istream& ins, <CX=r> GeneratedEnumName <=CX>& val ); /*noexcept*/

  friend <CX=r> GeneratedEnumName <=CX> operator & (
    const <CX=r> GeneratedEnumName <=CX>& lhs, const <CX=r> GeneratedEnumName <=CX>& rhs ); /*noexcept*/
  friend <CX=r> GeneratedEnumName <=CX> operator ^ (
    const <CX=r> GeneratedEnumName <=CX>& lhs, const <CX=r> GeneratedEnumName <=CX>& rhs ); /*noexcept*/
  friend <CX=r> GeneratedEnumName <=CX> operator ~ (
    const <CX=r> GeneratedEnumName <=CX>& rhs ); /*noexcept*/
  friend <CX=r> GeneratedEnumName <=CX> operator | (
    const <CX=r> GeneratedEnumName <=CX>& lhs, const <CX=r> GeneratedEnumName <=CX>& rhs ); /*noexcept*/
  friend <CX=r> GeneratedEnumName <=CX> operator &= (
    <CX=r> GeneratedEnumName <=CX>& lhs, const <CX=r> GeneratedEnumName <=CX>& rhs ); /*noexcept*/
  friend <CX=r> GeneratedEnumName <=CX> operator ^= (
    <CX=r> GeneratedEnumName <=CX>& lhs, const <CX=r> GeneratedEnumName <=CX>& rhs ); /*noexcept*/
  friend <CX=r> GeneratedEnumName <=CX> operator |= (
    <CX=r> GeneratedEnumName <=CX>& lhs, const <CX=r> GeneratedEnumName <=CX>& rhs ); /*noexcept*/

  friend bool operator <(const <CX=r> GeneratedEnumName <=CX> &a, const <CX=r> GeneratedEnumName <=CX> &b);
  friend bool operator <=(const <CX=r> GeneratedEnumName <=CX> &a, const <CX=r> GeneratedEnumName <=CX> &b);
  friend bool operator >(const <CX=r> GeneratedEnumName <=CX> &a, const <CX=r> GeneratedEnumName <=CX> &b);
  friend bool operator >=(const <CX=r> GeneratedEnumName <=CX> &a, const <CX=r> GeneratedEnumName <=CX> &b);

  friend _enumerated operator & (
    const _enumerated& lhs, const _enumerated& rhs ); /*noexcept*/
  friend _enumerated operator ^ (
    const _enumerated& lhs, const _enumerated& rhs ); /*noexcept*/
  friend _enumerated operator ~ (
    const _enumerated& rhs ); /*noexcept*/
  friend _enumerated operator | (
    const _enumerated& lhs, const _enumerated& rhs ); /*noexcept*/
  friend _enumerated operator &= (
    _enumerated& lhs, const _enumerated& rhs ); /*noexcept*/
  friend _enumerated operator ^= (
    _enumerated& lhs, const _enumerated& rhs ); /*noexcept*/
  friend _enumerated operator |= (
    _enumerated& lhs, const _enumerated& rhs ); /*noexcept*/

  bool test_flag ( _enumerated flag ) const noexcept;

  <CX=r> GeneratedEnumName <=CX>(const _enumerated value = _enumerated::TOTAL);

  operator _enumerated() const;

  ~<CX=r> GeneratedEnumName <=CX>() {}

  const <CX=r> GeneratedEnumName <=CX>& operator =(<CX=r> GeneratedEnumName <=CX> /*todo: support NOT only int*/ dummy) /*override*/ noexcept;

  const <CX=r> GeneratedEnumName <=CX>& operator =(_enumerated_t /*todo: support NOT only int*/ dummy) /*override*/ noexcept;

  const <CX=r> GeneratedEnumName <=CX>& operator =(const char* dummy) noexcept;

  static _enumerated FromString(const char* txt) noexcept;

  static _enumerated_t ToNumber(const _enumerated val) noexcept;

  static const char* ToString(const _enumerated val) /*override*/ noexcept;

  static _enumerated FromNumber(const _enumerated_t val) noexcept;

  const char* ToString() const /*override*/ noexcept;

  _enumerated_t ToNumber() const noexcept;

  /// \note for large number of elements
  /// consider <map> containing string hashes
  static constexpr std::array<_enumerated_t, _count> values_ =
      {
<CX=l>  { // startscope
<CX=l>    size_t elemIter = 0;
<CX=l>    for(const auto& [value, name]: GeneratedEnumItems) {
<CX=l>      const std::string delim  =
<CX=l>        (elemIter != GeneratedEnumItemsSize) ? "," : "";
        <CX=r>value<=CX> <CX=r>delim<=CX> // <CX=r>name<=CX>
<CX=l>      elemIter++;
<CX=l>    } // endfor
<CX=l>  } // endscope
      };

  static constexpr std::array<_name_t, _count> names_ =
      {
<CX=l>  { // startscope
<CX=l>    size_t elemIter = 0;
<CX=l>    for(const auto& [value, name]: GeneratedEnumItems) {
<CX=l>      const std::string delim  =
<CX=l>        (elemIter != GeneratedEnumItemsSize) ? "," : "";
        "<CX=r>name<=CX>" <CX=r>delim<=CX> // <CX=r>value<=CX>
<CX=l>      elemIter++;
<CX=l>    } // endfor
<CX=l>  } // endscope
      };
};

} // namespace cxxctp
} // namespace generated

// Support using as key in dictionaries and maps
namespace std {
    template <>
    struct hash<cxxctp::generated::<CX=r> GeneratedEnumName <=CX>> {
        size_t operator()(const cxxctp::generated::<CX=r> GeneratedEnumName <=CX>& ) const;
    };
}

<CX=l> if(!headerGuard.empty()) {
#endif // {{headerGuard}}
<CX=l> } // !headerGuard.empty()
